
\chapter{Taal en syntax}

In dit hoofdstuk zullen we de taal presenteren waarvoor we een natuurlijk taal construeren. De taal maakt gebruikt van prototype overerving en lexicaal bereik. Eerst zullen we een aantal voorbeeldprogramma's beschouwen, om zo informeel het karakter van de te formaliseren taal over te brengen. Daarna geven we een rigoreuze definitie met behulp van een BNF grammatica. De structuur van de productieregels van grammatica worden in latere hoofdstukken gebruikt om axioma's en deductieregels op te stellen. Daarmee heeft de grammatica in zekere zin een dubbele functie.

Elk voorbeeldprogramma en zijn toelichtingen worden als volg gepresenteerd:

\newCodeFragment[hev][Het eerste voorbeeldprogramma]
\codeFragmentCaption
\codeLines{
  \codeLine{\VAR \I{f}}[$\I{f}$ moet eerst worden gedefiniëerd]
  \codeLine{\I{f} = \FUN(i) \RETURNS \I{n}}
  \codeLine{\IN \VAR \I{n}}
  \codeLine{\IN \I{n} = 2 \times (\I{i} + 5)}
  \codeLine{}[$\I{x}$ bestaat niet in deze scope]
  \codeLine{\VAR \I{x}}[$\I{x}$ is ongedefinieerd (maar wel aanwezig)]
  \codeLine{\I{x} = \I{f}(42)}
}

De toelichtingen moeten als informeel commentaar worden beschouwd, waarmee we aan proberen te geven hoe het programma zich gedraagt. Vaak zijn het uitspraken over de toestand waarin het programma zich bevindt, direct na de linker regel te hebben ``uitgevoerd''.

\section{Voorbeeldprogramma's}

Een variabele moet gedeclareerd worden, en pas daarna kan er een waarde aan worden toegekend.

\newCodeFragment
\codeLines{
  \codeLine{}[$\I{x}$ bestaat niet (in deze scope)]
  \codeLine{\VAR \I{x}}[$\I{x}$ is ongedefinieerd (maar wel aanwezig)]
  \codeLine{\I{x} = 5}[$\I{x} = 5$]
}

Het concept van declaratie is juist in deze taal, gezien het lexicaal bereik van variabelen, heel belangrijk. Vergelijk het bovenstaande programma fragment bijvoorbeeld met de volgende situatie.

Variabelen hebben geen vaste type. Er zijn drie typen waarden in de taal: getallen, functies en objecten.

\newCodeFragment
\codeLines{
  \codeLine{\VAR \I{x}}
  \codeLine{\I{x} = 5}                       [de waarde van $\I{x}$ is een getal]
  \codeLine{\I{x} = \FUN()\,\{\;\SKIP\;\}}   [de waarde van $\I{x}$ is een functie]
  \codeLine{\I{x} \OBJECT}                   [de waarde van $\I{x}$ is een object]
}

De taal is object georienteerd.

\newCodeFragment
\codeLines{
  \codeLine{\VAR \I{o}}
  \codeLine{\I{o} \OBJECT}
  \codeLine{}                            [$\I{o}.\I{f}$ is niet gedefinieerd]
  \codeLine{\I{o}.\I{f} = \FUN()\,\{\;\SKIP\;\}} [toekenning waarde aan object attribuut]
  \codeLine{}                            [$\I{o}.\I{f}$ is wel gedefinieerd]
  \codeLine{\I{o}.\I{n} = 5}
}

Van de drie typen, zijn getallen en functies \emph{primitief}, en objecten \emph{niet primitief}. Primitieve waarde worden zelf gekopieerd (\emph{by-value}), maar van niet-primitieve waarden worden \emph{referenties} gekopieerd (\emph{by-reference}).

\newCodeFragment
\codeLines{
  \codeLine{\VAR \I{x};\; \I{x} = 6}
  \codeLine{\VAR \I{y};\; \I{y} = \I{x}}             [$\I{x} = 6$ en $\I{y} = 6$]
  \codeLine{\I{y} = 7}                       [$\I{x} = 6$ en $\I{y} = 7$]
  \codeLine{}
  \codeLine{\VAR \I{p};\; \I{p}.\I{n} = 6}
  \codeLine{\VAR \I{q};\; \I{q} = \I{p}}             [$\I{p}$ en $\I{q}$ verwijzen nu naar hetzelfde object]
  \codeLine{}                            [$\I{p}.\I{n} = 6$ en $\I{q}.\I{n} = 6$]
  \codeLine{\I{q}.\I{n} = 7}                     [$\I{p}.\I{n} = 7$ en $\I{q}.\I{n} = 7$]
}

\subsection{Lexical scope}

Als in een zekere scope een variabele wordt gereferenceerd (nog) niet is gedefinieerd, wordt in omliggende scopes ``gezocht'' naar een definitie van deze variabele.

\newCodeFragment[exa:lexical]

\codeLines{
  \codeLine{\VAR \I{x}}
  \codeLine{\VAR \I{f};\; \I{f} = \FUN(i)}
  \codeLine{\IN \I{x} = \I{i} + 5}
  \codeLine{}
  \codeLine{\I{f}(5)}[$\I{x} = 10$]
}

..maar wanneer deze wel in de huidige scope bestaat, worden omliggende scopes ``met rust gelaten''.

\newCodeFragment

\codeLines{
  \codeLine{\VAR \I{x}}
  \codeLine{\VAR \I{f}}
  \codeLine{\I{f} = \FUN(i)}
  \codeLine{\IN \VAR \I{x}}
  \codeLine{\IN \I{x} = \I{i} + 5}
  \codeLine{}
  \codeLine{\I{f}(5)}[$\I{x}$ heeft nog geen waarde]
}

Telkens wanneer een functie wordt aangeroepen, wordt een \emph{nieuwe scope} aangemaakt voor lokale variabelen. Variabelen van deze nieuwe scope kunnen later nog gereferenceerd worden, doordat bijvoorbeeld de functie een lokale functie teruggeeft.

\newCodeFragment

\codeLines{
  \codeLine{\VAR \I{f}}
  \codeLine{\I{f} = \FUN(n) \RETURNS \I{g}}
  \codeLine{\IN \VAR \I{g}}
  \codeLine{\IN \I{g} = \FUN() \RETURNS \I{n}}
  \codeLine{\IN \IN \I{n} = \I{n} + 1}
  \codeLine{}
  \codeLine{\VAR \I{c}}
  \codeLine{\I{c} = \I{f}(5)}[$\I{c}() \rightarrow 6, 7, 8, \dots$]
}

\begin{lstlisting}[caption=Een countervoorbeeld,label=exa:counter]
local f
f = function(n) returns g
    local g
    g = function() returns n
        n = n + 1

local c
c = f(5)
c()                          # $\rightarrow 6, 7, 8, \dots$
\end{lstlisting}

\fbox{maar dan wat beter geschreven, etc...}

\subsection{Prototype overerving}

\begin{KelleyWouldRemove}
Prototype overerving is een \KelleySaysNo{eenvoudige en dynamische} variant van object-geörienteerd programmeren. Net als in klassieke object-gebaseerde talen is er sprake van een object waarin \emph{attributen} zijn gedefinieerd. Elk object heeft ook een expliciete \emph{ouder} (of \enquote{parent}). Wanneer we binnen een object een attribuut willen evalueren, doen we dit in drie stappen:
\end{KelleyWouldRemove}

\begin{KelleyWouldAdd}
Prototype overerving is een variant van object-geörienteerd programmeren. Het kern-idee van object-geörienteerd programmeren is het concept van een \emph{object}, die ertoe dient een verschijnsel in de werkelijkheid na te bootsen (een reëel object, een patroon, een abstract idee). Het doel is om meer te kunnen programmeren op een conceptueel niveau. Daarmee wordt bijvoorbeeld zowel creatie als onderhoud van de code makkelijker.
\end{KelleyWouldAdd}

\begin{KelleyWouldAdd}
Veel objecten zullen natuurlijk gelijke eigenschappen vertonen, of dezelfde structuur hebben. Verder wilt men concepten als specificering en generalisering toepassen op objecten. Deze problemen kunnen op meerdere manieren worden aangepakt. De bekende variant, \emph{class-based}, ook wel \emph{klassieke}, object-oriëntatie richt zich op het concept van een \emph{klasse}, die de structuur en gedrag van een groep objecten specificeert. Objecten van een bepaalde klasse vertonen dan de structuur en gedrag van die klasse, en heten \emph{instanties}. Van specificering is sprake als een klasse eigenschappen van een andere klasse \emph{overerft}. Klassieke object-oriëntatie vind men in talen als Java en C\#.
\end{KelleyWouldAdd}

\begin{KelleyWouldAdd}
Een andere aanpak met hetzelfde doel is \emph{prototype overerving}. Daarbij wordt geen scheiding gemaakt tussen de concepten \emph{klasse}, die structuur en gedrag specificeert, en \emph{instantie}, die enkel deze eigenschappen vertoont. In plaats daarvan wordt gewerkt met een prototype structuur, waarbij elk object naar een bepaald \emph{prototype} object referenceert. Nu zijn objecten zelf de dragers van structuur en gedrag. \textit{Deze methode kan als flexibeler worden gezien, maar ook als een wat minder reëel beeld van de werkelijkheid worden opgevat.}
\end{KelleyWouldAdd}

\begin{KelleyWouldAdd}
Technisch gezien werkt prototype overerving als volgt. Van elk object is een prototype bekend, of het heeft geen prototype. Wanneer men een attribuut opvraagt van een zeker object, kan de op te leveren waarde procedureel als volgt worden opgevat:
\end{KelleyWouldAdd}

\begin{enumerate}
  \item Bekijk of het attribuut gedefiniëerd is in het object zelf. In dat geval weten we de waarde en leveren deze op.
  \item Anders zoeken we het attribuut op in \KelleySaysNo{de ouder} \KelleySays{het prototype} van het object. Ook dan weten we de waarde en leveren deze op.
  \item Wanneer ook \KelleySaysNo{de ouder} \KelleySays{het prototype} het attribuut niet bevat, herhalen we de zoektocht voor alle volgende \KelleySaysNo{ouders} \KelleySays{prototypen} totdat we het attribuut hebben gevonden.
\end{enumerate}

\KelleySaysNo{Ook hier is dus sprake van een boomstructuur.}

Het grote verschil tussen object-gebaseerde talen en prototype-gebaseerde talen is \KelleySays{dus} dat de tweede geen onderscheid maakt tussen \emph{klassen} en \emph{instanties}. Een prototype heeft beide functies. Neem bijvoorbeeld het \KelleySaysNo{prototype} \KelleySays{object} @Deur@\KelleySays{, welke als prototype gebruikt dient te worden}:

\newCodeFragment

\codeLines{
  \codeLine{\VAR \I{Deur}}
  \codeLine{\I{Deur} \OBJECT}
}

We kunnen @Deur@ direct als instantie gebruiken door een attribuut te zetten:

\codeLines{
  \codeLine{\I{Deur}.\I{open} = 1}
}

Een @Deur@ is standaard open. Maar we kunnen @Deur@ ook als een \KelleySaysNo{klasse} \KelleySays{prototype} gebruiken\KelleySaysNo{ door ervan te erven}. In \KelleySays{de meeste huidige} prototype-gebaseerde talen heet dit \emph{klonen}:

\codeLines{
  \codeLine{\VAR \I{GeslotenDeur}}
  \codeLine{\I{GeslotenDeur} \OBJECT}
	\codeLine{\I{GeslotenDeur} \CLONES \I{Deur}}
}

@GeslotenDeur@ heeft dan alle attributen van @Deur@:

\codeLines{
  \codeLine{\I{GeslotenDeur}.\I{open}}[waarde $\to$ 1]
}

Maar een @GeslotenDeur@ moet natuurlijk gesloten zijn. We zetten zijn attribuut @open@ op @0@:

\codeLines{
	\codeLine{\I{GeslotenDeur}.\I{open} = 0}
}

Een gewone @Deur@ is nog steeds open:

\codeLines{
  \codeLine{\I{Deur}.\I{open}}[waarde $\to$ 1]
}

Attributen worden dus per object bewaard. Door @open@ op @0@ te zetten in @GeslotenDeur@ verandert er niks in @Deur@.

We kunnen net zoveel klonen maken van een object als we willen en net zo diep klonen als we willen. Neem een @GlazenDeur@, dit is natuurlijk ook een @Deur@, maar wel doorzichtig:

\codeLines{
  \codeLine{\VAR \I{GlazenDeur}}
  \codeLine{\I{GlazenDeur} \OBJECT}
  \codeLine{\I{GlazenDeur} \CLONES \I{Deur}}
  \codeLine{\I{GlazenDeur}.\I{doorzichtig} = 1}
}

Een gewone @Deur@ heeft het attribuut @doorzichtig@ niet, en dus een @GeslotenDeur@ ook niet:

\codeLines{
  \codeLine{\I{GeslotenDeur}.\I{doorzichtig}}[fout!]
}

Maar we kunnen besluiten dat deuren standaard niet doorzichtig zijn:

\codeLines{
  \codeLine{\I{Deur}.\I{doorzichtig} = 0}
}

Zodat ook onze @GeslotenDeur@ niet doorzichtig is:

\codeLines{
  \codeLine{\I{GeslotenDeur}.\I{doorzichtig}}[waarde $\to$ 0]
}

Maar er geld nog steeds:

\codeLines{
  \codeLine{\I{GlazenDeur}.\I{doorzichtig}}[waarde $\to$ 1]
}

We zien dat we met prototypes een zeer flexibele methode hebben om object-geörienteerd te programmeren. Het is niet nodig om de compiler of parser van te voren uit te leggen dat objecten aan bepaalde \enquote{blauwdrukken} moeten voldoen. We creëren objecten \enquote{on-the-fly}, alsmede hun attributen en relaties. Deze methode komt terug in talen als JavaScript, IO en Self.

Natuurlijk is het ook mogelijk om \emph{methoden} te definiëren. Dit zijn \KelleySaysNo{functies} \KelleySays{gewoonweg functie attributen} die gekoppeld zijn aan een specifiek object. Stel dat we een @GeslotenDeur@ graag open willen maken. We definiëren:

\codeLines{
  \codeLine{\I{GeslotenDeur}.\I{ontsluit} = \FUN (\I{poging})}
  \codeLine{\IN \IF (\I{poging} = \THIS.\I{code}) \THEN}
  \codeLine{\IN \IN \THIS.\I{open} = 1}
  \codeLine{\IN \ELSE}
  \codeLine{\IN \IN \THIS.\I{open} = 0}
}

@this@ is hier een expliciete verwijzing naar het huidige object. Op dit moment kunnen we @ontsluit@ nog niet aanroepen op @GeslotenDeur@:

\codeLines{
  \codeLine{\I{GeslotenDeur}.\I{ontsluit}(1234)}[fout!]
}

Het attribuut @code@ is immers niet gedefinieerd in @GeslotenDeur@ noch in zijn prototype @Deur@.

We kunnen natuurlijk een @code@ toekennen aan @GeslotenDeur@, maar laten we een specifieke @GeslotenDeur@ maken met een @code@:

\codeLines{
  \codeLine{\VAR \I{Kluis}}
  \codeLine{\I{Kluis} \OBJECT}
  \codeLine{\I{Kluis} \CLONES \I{GeslotenDeur}}
  \codeLine{\I{Kluis}.\I{code} = 4321}
}

Wanneer we de methode @ontsluit@ aanroepen is deze niet gedefinieerd in @Kluis@, maar wel in zijn prototype @GeslotenDeur@. Die wordt dan uitgevoerd. Een belangrijke observatie is dat @ontsluit@ wel wordt aangeroepen op @Kluis@. Dat betekent dat @this@ verwijst naar @Kluis@ en niet @GeslotenDeur@. Het attribuut @code@ wordt dan wel gevonden!

\codeLines{
  \codeLine{\I{Kluis}.\I{ontsluit}(1234)}
  \codeLine{\I{Kluis}.\I{open}}[waarde $\to$ 0]
}

Oeps\dots Dat was de verkeerde code, nog een poging:

\codeLines{
  \codeLine{\I{Kluis}.\I{ontsluit}(1234)}
  \codeLine{\I{Kluis}.\I{open}}[waarde $\to$ 1]
}

\section{Grammatica}

Nu volgt een formele definitie van de syntax van de taal, aan de hand van een BNF grammatica. Nummers zijn als volgt gedefiniëerd:
%
\begin{align*}
  \Num \GrammarDef (0 \mid 1 \mid 2 \mid 3 \mid 4 \mid 5 \mid 6 \mid 7 \mid 8 \mid 9)^+
\end{align*}
%
Eigenlijk gebruiken we geen stricte BNF, in deze specifieke gevallen, maar een hele simpele variant, zoals E-BNF, waarbij de ook simpele reguliere expressies toelaten. Bovenstaand voorbeeld maakt dit duidelijk. Voorbeelden van elementen uit $\Num$ zijn ``0'', ``1'', ``235783'' en ``0003''. Voorbeelden van elementen die niet in $\Num$ zitten zijn ``'', ``-6'', ``4.2''.

\emph{Identifiers}, die gebruikt worden als variabel-namen, zijn op eenzelfde manier als volgt gedefiniëerd:
%
\begin{align*}
  \Id \GrammarDef (a \mid b \mid c \mid d \mid \dots)^+
\end{align*}
%
Hierbij moet je je natuurlijk voorstellen dat alle letters uit het alfabet in de grammaticaregel staan op de voordehandliggende manier.

Het is soms ook nodig om meerdere komma-gescheiden variabel-namen te gebruken, of een mogelijk lege-lijst, zoals bij functie definitie. Vandaar de volgende twee productieregels:
%
\begin{align*}
  \Ids \GrammarDef \Id \mid \Ids, \Id \\
  \MaybeIds \GrammarDef \varepsilon \mid \Ids
\end{align*}
%
Een \emph{slot} is een opeenvolging door punten (``.'') gescheiden identifiers, en wordt gebruikt om ook naar attributen van objecten te kunnen referenceren:
%
\begin{align*}
  \Slot \GrammarDef \Id \mid \Id . \Slot
\end{align*}
%
\emph{Expressies}, die ofwel primitieve waarden (getallen en functies), ofwel objecten kunnen weergeven, en \emph{boolse expressies}, die gebruikt worden voor loops en conditionele executie, zijn als volgt gedefiniëerd:
%
\begin{align*}
  \Expr \GrammarDef \Num \mid \Slot \mid \varnothing \mid \Expr\; (+ \mid - \mid \times \mid /\,)\; \Expr \\
  \GrammarOr \FUN\pmb{(}\,\MaybeIds\,\pmb{)}\; \GrammarOpt{\RETURNS \Id\;} \pmb{\{}\; \Stm\; \pmb{\}} \\
  \Exprs \GrammarDef \Expr \mid \Exprs, \Expr \\
  \ExprsMaybe \GrammarDef \varepsilon \mid \Exprs \\
  \B \GrammarDef \TRUE \mid \FALSE \\
  \GrammarOr \B\; (\AND \mid \OR)\; \B \\
  \GrammarOr \NOT\; \B \\
  \GrammarOr \Expr\; (=\: \mid\: <\: \mid\: \le\: \mid\: >\: \mid\: \ge)\; \Expr
\end{align*}
%
De kern van de hele grammatica draait om de volgende productieregels, die van \emph{statements}. Een statement is een programma van goede vorm. Het betekent niet nodelijkerwijs dat het programma \emph{valide} is, maar alle valide programma's zitten wel in $\Stm$.
%
\begin{align*}
  \Stm \GrammarDef \Stm; \Stm \\
  \GrammarOr \SKIP \\
  \GrammarOr \IF \B \THEN \Stm \ELSE \Stm \\
  \GrammarOr \WHILE \B \DO \Stm \\
  \GrammarOr \LOCAL \Id \\
  \GrammarOr \Slot = \Expr \\
  \GrammarOr \GrammarOpt{\Slot =} \Id\,\pmb{(}\,\ExprsMaybe\,\pmb{)} \\
  \GrammarOr \Id \CLONES \Id \\
  \GrammarOr \Id \OBJECT
\end{align*}
%
Vanwege de focus van dit werkstuk definiëren we niet precies wanneer een programma valide is en wanneer niet.

% vim: spell spl=nl
