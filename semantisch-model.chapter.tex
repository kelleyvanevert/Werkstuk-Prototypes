\chapter{Semantisch model}

\section{Bindingen}\label{sec:bindingen}

Aan de basis van ons model ligt het concept van een \emph{binding}. Een binding is een toekenning van een \emph{waarde} aan een variabele (een element uit de syntactische verzameling \Id). Bindingen zijn bijvoorbeeld van belang om de gedefiniëerd variabelen binnen een scope vast te leggen, of de attributen van een bepaald object. Een \emph{groep bindingen} is een eindige functie $b : \Id \to \VV$. De verzameling van alle groepen van bindingen definiëren we dus als
\begin{equation*}
  \BB \DEF \FiniteFunctions{\VV}{\Id}
\end{equation*}
We komen later terug op wat de waarden $\VV$ precies zijn in §\ref{sec:waarden}. Voor nu is het voldoende om te weten dat in ieder geval de natuurlijke getallen $\NN$ deel uitmaken van $\VV$.

Bindingen komen veelvuldig terug in ons model. In scopes worden \emph{variabelen} gedeclareerd en aan waarden gekoppeld. Bij objecten zijn het de \emph{attributen} die waarden krijgen toegekend.

\section{Scope en omliggende scopes}

In sectie \ref{sec:voorbeelden} is informeel gebleken dat scopes conceptueel goed te zien zijn als een boomstructuur. Stel we evalueren een variabele \id{x} in scope $s$:

\newCodeFragment
\codeLines{
  \codeLine{\id{x}}[We bevinden ons in een zekere scope $s$.]
}

dan kunnen we dit als volgt uitleggen. Eerst zoeken we \id{x} op in de bindingen groep $b_s$, behorende bij scope $s$.
%
\begin{equation*}
  b_s(x).
\end{equation*}
%
Vervolgens moet er gevalsonderscheiding worden gedaan voor de volgende situaties:

\begin{enumerate}
  \item \id{x} is gedefiniëerd in $b_s$, dus gebruiken we de gevonden waarde.
  \item \id{x} is niet gedefiniëerd in $b_s$, dus moeten we \id{x} opzoeken in de omgevende scope.
\end{enumerate}

Hieruit blijkt dat we voor een willekeurige scope niet alleen zijn eigen bindingen moeten bijhouden, maar ook een verwijzing naar zijn \emph{omgevende scope}. Een scope $s$ definiëren we daarom als een paar $(b, \pi)$, met $b$ de bindingen en $\pi$ een \emph{verwijzing} naar de omgevende scope (ook wel \emph{parent}, of \emph{outer} scope).

We moeten benadrukken dat $\pi$ een \emph{verwijzing} is, en niet een \emph{kopie} van de bindingen groep van de omgevende scope. Stel dat we het programma in code fragment~\ref{exa:lexical} uitvoeren. Op het moment dat we $f()$ aanroepen in regel~\ref{exa:lexical:eerste} willen we dat $x$ daarna evalueert naar de waarde $2$. Evenzo moet $x$ na regel~\ref{exa:lexical:tweede} evalueren naar de waarde $4$. De scope $s_f$ van functie $f$ heeft een eigen binding $b_f$ die gedurende de executie van het programma leeg is, $x$ is namelijk niet gedeclareerd als een \LOCAL variabele. De omgevende scope $\pi_f$ van functie $f$ verwijst naar scope $s$, zodat de variabele $x$ uiteindelijk wel gevonden wordt.

\newCodeFragment[exa:lexical][Lexicale scope: opslaan en vinden van variabelen]
\codeFragmentCaption
\codeLines{
  \codeLine{\VAR \id{x}}
  \codeLine{\id{x} = 1}
  \codeLine{\VAR \id{f}}
  \codeLine[exa:lexical:def]{\id{f} = \FUN()}[Introductie nieuwe scope]
  \codeLine{\IN \id{x} = 2 \times \id{x}}
  \codeLine{}[Einde nieuwe scope]
  \codeLine[exa:lexical:eerste]{\id{f}()}[$\id{x} = 2$]
  \codeLine[exa:lexical:tweede]{\id{f}()}[$\id{x} = 4$]
}

Stel nu dat we geen verwijzing in de scope opslaan, maar een kopie van de omgevende bindingen. Op het moment dat we $f$ definiëren in regel~\ref{exa:lexical:def} is scope $s_f$ een paar $(b_f, p_f)$ met $b_f \in \BB$. Net als hierboven zijn de eigen bindingen $b_f$ leeg. De binding $p_f$ bevat een functie onder naam \id{f} en de waarde $1$ onder naam \id{x}. Wanneer we \id{x} aanpassen door de aanroep in regel~\ref{exa:lexical:eerste} wordt dit doorgevoerd in de binding $p_f$ maar, omdat dit een kopie is, niet in de binding $b_s$ van de omgevende scope $s$. We moeten dus wel een verwijzing opslaan willen we het gevraagde gedrag krijgen. Daarnaast wordt het met kopieën erg lastig om een boomstructuur te creëren zodat we een variabele nog hogerop kunnen opzoeken.

Een scope $s$ is dus een element uit de verzameling
%
\begin{equation*}
  \SS \DEF \BB \times (\LLs \cup \{\nil\}).
\end{equation*}
%
Hierbij zijn $\BB$ de bindinggroepen zoals besproken in §\ref{sec:bindingen}. $\LLs$ zijn locaties van scopes. Op het begrip ``locatie'' komen wij nog terug in §\ref{sec:locaties}. We moeten er wel rekening mee houden dat er een soort ``ultieme'' omgevende scope is. Het kan dus zijn dat een scope geen parent heeft. Voor dat geval introduceren we het unieke element $\nil$. De beoogde interpretatie van een scope van de vorm $(b, \nil)$ is dan dat het geen omgevende scope heeft.

\section{Objecten en prototype overerving}

In §\ref{sec:taal-prototypen} hebben we een beeld gekregen van prototype overerving. Net als scopes en omgevende scopes, worden objecten en hun prototypen het best gemodelleerd met een boomstructuur. Geheel in lijn met scopes is een object een paar met daarin zijn eigen bindingen $b$ en een verwijzing naar zijn prototype $\pi$. Natuurlijk kan een object ook geen prototype hebben. Dit geven we weer aan met $\nil$. Een object $o$ is dus een element uit
%
\begin{equation*}
  \OO \DEF \BB \times (\LLo \cup \{\nil\}).
\end{equation*}
%
Hierbij is $\BB$ weer de verzamelingen bindinggroepen uit §\ref{sec:bindingen} en $\LLo$ zijn ditmaal locaties van objecten.

Hoewel het semantische model voor objecten en hun prototypen vrijwel identiek is aan het semantische model voor scopes, hebben ze een andere betekenis. Om deze gelijkheid te benadrukken gebruiken we voor beide modellen een aantal zelfde letters, en om de ongelijkheid te benadrukken subscripten we de locatie verzamelingen ($\LLo$ en $\LLs$).

\section{Waarden: referenties en primitieven}
\label{sec:waarden}

In voorgaande paragrafen spraken we over waarden $\VV$ en locaties $\LL$ ($\LLs$ voor scopes $\LLo$ voor objecten). We hebben de exacte definities hiervan in het midden gelaten. Een waarde $v \in \VV$ is iets wat we toekennen aan een \Id\ met behulp van een binding. In §\ref{subsec:taal-types} is uitgelegd hoe de taal over verschillende typen data kan spreken. In onze taal komen drie typen data voor: getallen, functies en objecten. Er is echter een verschil in de manier waarop wij ze behandelen.

Wat gebeurt er wanneer we bovenstaande waardes opnieuw toekennen aan andere variabelen? Allereerst een natuurlijk getal, deze is het eenvoudigst:
\begin{lstlisting}
local m
m = n
\end{lstlisting}
Op dit moment hebben zowel @m@ als @n@ waarde @5@. Wanneer we aan @m@ een andere waarde toekennen, gebeurt er niets met @n@. Omgekeerd geld hetzelfde. We kunnen dus simpelweg de waarde van @n@ \emph{kopiëren} en in @m@ stoppen. Onze waardes $\VV$ bevatten dus sowieso $\NN$:
\begin{equation*}
  \VV \DEF \NN
\end{equation*}

Voor functies geld eigenlijk hetzelfde:
\begin{lstlisting}
local g
g = f
\end{lstlisting}
@g@ heeft nu als waarde een kopie van de functie in variabele @f@. Beiden kunnen we aanroepen:
\begin{lstlisting}
f(4)                         # => 8
g(6)                         # => 12
\end{lstlisting}
Dus $\VV$ bevat ook functies:
\begin{equation*}
  \VV \DEF \NN \cup \VV
\end{equation*}

Helaas gaat dit \emph{niet} op voor objecten. Stel dat @A@ een attribuut @x@ heeft
\begin{lstlisting}
A.x = 7
\end{lstlisting}
en we koppelen een nieuwe variabele $B$ aan het object in $A$:
\begin{lstlisting}
local B
B = A
\end{lstlisting}
Nu heeft @B@ sowieso dezelfde attributen als @A@:
\begin{lstlisting}
B.x                          # => 7
\end{lstlisting}
Maar als we @x@ in @B@ ophogen
\begin{lstlisting}
B.x = 8
\end{lstlisting}
moet dit in @A@ natuurlijk ook gebeuren:
\begin{lstlisting}
A.x                          # => 8
\end{lstlisting}
Wanneer we zomaar een kopie van de waarde in @A@ aan @B@ toekennen, zou het attribuut @A.x@ niet gewijzigd worden. Een oplossing is om in plaats van een kopie van een object een \emph{referentie} naar een object aan een variabele te koppelen. Dit zijn dus niet elementen uit $\OO$ zelf, maar uit $\LLo$. Dat betekend dat objecten niet op dezelfde manier worden behandeld als getallen en functies, maar de \emph{locaties} van objecten wel. Voor de waardes krijgen we dus
\begin{equation*}
  \VV \DEF \LLo \cup \NN \cup \VV.
\end{equation*}

Primitieve waardes in onze taal koppelen we \emph{by-value}. Dit zijn natuurlijke getallen en functies. Objecten daarentegen worden \emph{by-reference} gekoppeld. Deze referenties zijn elementen uit $\LLo$. Achter de schermen worden deze gebruikt om objecten door te geven en worden op hun beurt wel \emph{by-reference} gekoppeld.

\section{Functies}
\label{model-functies}

TODO

\section{Locaties en geheugen}\label{sec:locaties}

Uit de redenaties over referenties volgt dat we een plaats moeten hebben om alle objecten op te slaan. Dit noemen we het \emph{geheugen voor objecten} $m_o$. Voor een gegeven locatie $\omega\in\LLo$ kunnen we het bijbehorende object in een geheugen $m_o$ opzoeken met
\begin{equation*}
  m_o(\omega).
\end{equation*}
Een geheugen is dus een functie van locaties naar objecten. De verzameling van alle geheugens definiëren we als
\begin{equation*}
  \MMo \DEF \OO^{\LLo}.
\end{equation*}
Dan is $m_o$ een element hier uit.

\section*{Extra}

\begin{align*}
  \tag*{locaties van scopes en objecten}
  \LL &\DEF \{ (n, n) \in \NN^2 \} \\
  \tag*{functies}
  \FF &\DEF \Stm \times \Id_{\langle\rangle} \times (\Id \cup \{\nil\}) \times \LL \\
  \tag*{waarden}
  \VV &\DEF \LL \cup \NN \cup \FF \\
  \tag*{binding-verzamelingen}
  \BB &\DEF \FiniteFunctions{\VV}{\Id} \\
  \tag*{objecten}
  \OO &\DEF \BB \times (\LL \cup \{\nil\}) \\
  \tag*{scopes}
  \SS &\DEF \BB \times (\LL \cup \{\nil\}) \\
\end{align*}

% vim: syn=latex spell spl=nl cole=1 cocu=nv
