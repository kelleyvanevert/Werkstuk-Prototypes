
\chapter{Natuurlijke Semantiek}

%Deze teksten zijn vooral bedoeld als ``tekstvlees'' (lorem ipsum's). We zullen axioma's en deductieregels introduceren waarmee we de relatie $(\longrightarrow)$ definiëren, die de volgende signatuur heeft:

%$$ (\longrightarrow) \subseteq (\Stm \times \MM \times \LL \times \LL) \times \MM $$

%Wanneer we een uitspraak doen van de vorm:

%$$ \Config{S}{m,\sigma,\tau} \longrightarrow m' $$

%..dan bedoelen we daarmee dat:

%$$ \big(\,(S,m,\sigma,\tau), m'\,\big) \in (\longrightarrow) $$

Deze uitspraak moet je lezen als: ``In de toestand met geheugen $m$, scope $\sigma$ en \emph{this} object $\tau$, termineert het statement $S$, waarbij het resultaat-geheugen $m'$ is.''

Een van deze axioma's [object], heeft betrekking tot de productieregel in de grammatica die de $\OBJECT$ ``literal'' introduceert.

\begin{NSAxiom}{object}
  \begin{prooftree}
    \AxiomC{$
      \Config{i \OBJECT}{m, \sigma, \tau}
      \longrightarrow
      m''
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \textsc{Find}_m(\sigma, i) = \sigma_\text{def} $}
    \Cond{$ m' = m \surr{ \sigma_\text{def} \mapsto \big(b_{m(\sigma')}[i\mapsto \omega], p_{m(\sigma')}\big) } $}
    \Cond{$ m'' = m' \surr{ \omega \mapsto \big(\varnothing, \BOT\big) } $}
  \end{NSConditions}
\end{NSAxiom}

Zoals vele axioma's en deductieregels heeft ook dit axioma een aantal voorwaarden waaraan moet worden voldaan. Deze staan eronder genoteerd, elk op een regel.

Wanneer bij een dergelijke opsomming van voorwaarden een nieuwe variabele wordt geïntroduceerd zoals hierboven, met de volgende vorm: $\textbf{desda } \square = \theta \dots$; dan moet deze gelezen worden als: $\textbf{desda } \exists_\theta \big[\, \square = \theta \dots \,\big]$.

\section{}

Laten we beginnen met de simpelste constructie in onze taal, het lege statement \SKIP. Deze heeft de vorm van een axioma.

\begin{NSAxiom}{skip}
  \begin{prooftree}
    \AxiomC{$
      \Config{\SKIP}{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s, m_o)
    $}
  \end{prooftree}
\end{NSAxiom}

Zoals we kunnen zien zijn onze uitspraken van de vorm
\begin{equation*}
  \Config{S}{m_s,m_o,\sigma,\tau} \longrightarrow (m_s',m_o').
\end{equation*}
Hiermee bedoelen we dat
\begin{equation*}
\big(\,(S,m_s,m_o,\sigma,\tau), (m_s',m_o')\,\big) \in (\longrightarrow),
\end{equation*}
waarbij $\longrightarrow$ de volgende signatuur heeft 
\begin{equation*}
  (\longrightarrow) \subseteq (\Stm \times \MM_s \times \MM_o \times \LL_s \times \LL_o) \times (\MM_s \times \MM_o).
\end{equation*}
Deze transitie werkt op een statement $S\in\Stm$ in een toestand $(m_s,m_o)\in(\MM_s,\MM_o)$ met als extra informatie de locatie van de huidige scope $\sigma\in\LL_s$ en de locatie van het huidige \THIS-object $\tau\in\MM_o$. Het resultaat is een nieuwe toestand in de vorm van de twee geheugens $(m_s',m_o')\in(\MM_s,\MM_o)$. \SKIP\ verandert niets aan de toestand zodat $(m_s',m_o')=(m_s,m_o)$.

Voor het samenstellen van statements hebben we een regel nodig.

\begin{NSAxiom}{comp}
  \begin{prooftree}
    \AxiomC{$
      \Config{S_1}{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s', m_o')
    $}
    \AxiomC{$
      \Config{S_2}{m_s', m_o', \sigma, \tau}
      \longrightarrow
      (m_s'', m_o'')
    $}
    \BinaryInfC{$
      \Config{S_1; S_2}{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s'', m_o'')
    $}
  \end{prooftree}
\end{NSAxiom}

In dit geval geven we aan dat, wanneer we een een compositie hebben van de statements $S_1$ en $S_2$, we eerst $S_1$ evalueren% T: Dit is niet het juiste woord, weten even geen betere...
en daarna $S_2$. Tijdens dit proces ontstaan nieuwe toestanden, waar we natuurlijk rekening mee moeten houden. De geheugens worden dan ook netjes doorgesluisd.

De controlestructuur \IF\ heeft twee regels, een voor het geval dat de \BExpr\ evalueert in \T\ en een voor het geval dat deze evalueert in \F.

\begin{NSAxiom}{if$^\T$}
  \begin{prooftree}
    \AxiomC{$
      \Config{S_1}{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s', m_o')
    $}
    \UnaryInfC{$
      \Config{\IF b \THEN  S_1 \ELSE S_2 }{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s', m_o')
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \Surr{b}^\text{B}_{m_s, m_o,\sigma,\tau} = \T $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

\begin{NSAxiom}{if$^\F$}
  \begin{prooftree}
    \AxiomC{$
      \Config{S_2}{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s', m_o')
    $}
    \UnaryInfC{$
      \Config{\IF b \THEN S_1 \ELSE S_2 }{m_s, m_o, \sigma, \tau}
      \longrightarrow
      (m_s', m_o')
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \Surr{b}^\text{B}_{m_s, m_o,\sigma,\tau} = \F $}
  \end{NSConditions}
\end{NSAxiom}


\section{Regels}

\begin{NSAxiom}{clones}
  \begin{prooftree}
    \AxiomC{$
      \Config{i \CLONES j}{m, \sigma, \tau}
      \longrightarrow
      m'
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \Surr{i}_{m,\sigma,\tau} = \omega_i \in \LL $}
    \Cond{$ \Surr{j}_{m,\sigma,\tau} = \omega_j \in \LL $}
    \Cond{$ m' = m \surr{ \omega_i \mapsto \big(b_{m(\omega_i)}, \omega_j\big) } $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

\begin{NSAxiom}{declare}
  \begin{prooftree}
    \AxiomC{$
      \Config{\VAR i}{m, \sigma, \tau}
      \longrightarrow
      m'
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ m' = m \surr{ \sigma \mapsto \big(b_{m(\sigma)}[i \mapsto \BOT], p_{m(\sigma)}\big) } $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

\begin{NSAxiom}{assign$^\text{this}$}
  \begin{prooftree}
    \AxiomC{$
      \Config{\THIS.s = e}{m, \sigma, \tau}
      \longrightarrow
      m'
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \textsc{Trav}_m(\tau, s) = (\omega, i) $}
    \Cond{$ \Surr{e}_{m, \sigma, \tau} = v $}
    \Cond{$ m'= m \surr{ \omega \mapsto \big(b_{m(\omega)}[ i \mapsto v ], p_{m(\omega)}\big) } $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

\begin{NSAxiom}{assign$^\text{i}$}
  \begin{prooftree}
    \AxiomC{$
      \Config{i = e}{m, \sigma, \tau}
      \longrightarrow
      m'
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \sigma_\text{def} = \textsc{Find}_m(\sigma, i) $}
    \Cond{$ \Surr{e}_{m, \sigma, \tau} = v $}
    \Cond{$ m'= m \surr{ \sigma_\text{def} \mapsto \big(b_{m(\sigma_\text{def})}[ i \mapsto v ], p_{m(\sigma_\text{def})}\big) } $}
  \end{NSConditions}
\end{NSAxiom}


bla bla

\begin{NSAxiom}{assign$^\text{slot}$}
  \begin{prooftree}
    \AxiomC{$
      \Config{i.s = e}{m, \sigma, \tau}
      \longrightarrow
      m'
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \sigma_\text{def} = \textsc{Find}_m(\sigma, i) $}
    \Cond{$ b_{m(\sigma_\text{def})}(i) = \omega \in \LL $}
    \Cond{$ \textsc{Trav}_m(\omega, s) = (\omega', j) $}
    \Cond{$ \Surr{e}_{m, \sigma, \tau} = v $}
    \Cond{$ m'= m \surr{ \omega' \mapsto \big(b_{m(\omega')}[ j \mapsto v ], p_{m(\omega')}\big) } $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

\begin{NSAxiom}{call}
  \begin{prooftree}
    \AxiomC{$
      \Config{S_{\!f}}{m', \sigma_{\!f\text{new}}, \omega'}
      \longrightarrow
      m''
    $}
    \UnaryInfC{$
      \Config{i.s(e^*)}{m,\sigma,\tau}
      \longrightarrow
      m''
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \sigma_\text{def} = \textsc{Find}_m(\sigma, i) $}
    \Cond{$ b_{m(\sigma_\text{def})}(i) = \omega \in \LL $}
    \Cond{$ \textsc{Trav}_n(\omega, s) = (\omega', j) $}
    \Cond{$ (S_{\!f}, I_{\!f}, i_{\!f}, \sigma_{\!f\text{def}}) = f = b_{m(\omega')}(j) $}
    \Cond{$ \sigma_{\!f\text{new}} = \textsc{Next}_\text{scope}(m) $}
    \Cond{$ m' = m\surr{ \sigma_{\!f\text{new}} \mapsto \big(\Surr{e^*}^*_{m,\sigma,\tau}(I_{\!f}), \sigma_{\!f\text{def}}\big) } $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

bla bla

bla bla
bla bla

\begin{NSAxiom}{while$^\text{T}$}
  \begin{prooftree}
    \AxiomC{$
      \Config{S_1}{m, \sigma, \tau}
      \longrightarrow
      m'
    $}
    \AxiomC{$
      \Config{\WHILE (b) \DO \{ S_1 \}}{m', \sigma, \tau}
      \longrightarrow
      m''
    $}
    \BinaryInfC{$
      \Config{\WHILE (b) \DO \{ S_1 \}}{m, \sigma, \tau}
      \longrightarrow
      m''
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \Surr{b}^\text{B}_{m,\sigma,\tau} = \mathbf{T} $}
  \end{NSConditions}
\end{NSAxiom}

bla bla

\begin{NSAxiom}{while$^\text{F}$}
  \begin{prooftree}
    \AxiomC{$
      \Config{\WHILE (b) \DO \{ S_1 \}}{m, \sigma, \tau}
      \longrightarrow
      m
    $}
  \end{prooftree}
  \begin{NSConditions}
    \Cond{$ \Surr{b}^\text{B}_{m,\sigma,\tau} = \mathbf{F} $}
  \end{NSConditions}
\end{NSAxiom}

% vim: syn=latex spell spl=nl cole=1 cocu=nv
